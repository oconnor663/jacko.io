# Async Rust, Part Three: Choose your own adventure
###### \[date]

- [Part One: What's in it for us?](async_one.html)
- [Part Two: How does it work?](async_two.html)
- Part Three: Choose your own adventure (you are here)

## Cancellation

## Recursion

## Tasks

[Here's a custom event loop with a growable list of tasks.][tasks]

[tasks]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=use+futures%3A%3Atask%3A%3Anoop_waker_ref%3B%0Ause+std%3A%3Acollections%3A%3ABTreeMap%3B%0Ause+std%3A%3Afuture%3A%3AFuture%3B%0Ause+std%3A%3Apin%3A%3APin%3B%0Ause+std%3A%3Async%3A%3Ampsc%3A%3A%7Bchannel%2C+Sender%7D%3B%0Ause+std%3A%3Async%3A%3A%7BMutex%2C+OnceLock%7D%3B%0Ause+std%3A%3Atask%3A%3A%7BContext%2C+Poll%2C+Waker%7D%3B%0Ause+std%3A%3Atime%3A%3A%7BDuration%2C+Instant%7D%3B%0A%0Astatic+TASK_SENDER%3A+OnceLock%3CSender%3CPin%3CBox%3Cdyn+Future%3COutput+%3D+%28%29%3E+%2B+Send%3E%3E%3E%3E+%3D+OnceLock%3A%3Anew%28%29%3B%0Astatic+WAKERS%3A+Mutex%3CBTreeMap%3CInstant%2C+Vec%3CWaker%3E%3E%3E+%3D+Mutex%3A%3Anew%28BTreeMap%3A%3Anew%28%29%29%3B%0A%0Astruct+SleepFuture+%7B%0A++++wake_time%3A+Instant%2C%0A%7D%0A%0Aimpl+Future+for+SleepFuture+%7B%0A++++type+Output+%3D+%28%29%3B%0A%0A++++fn+poll%28self%3A+Pin%3C%26mut+Self%3E%2C+context%3A+%26mut+Context%29+-%3E+Poll%3C%28%29%3E+%7B%0A++++++++if+self.wake_time+%3C%3D+Instant%3A%3Anow%28%29+%7B%0A++++++++++++Poll%3A%3AReady%28%28%29%29%0A++++++++%7D+else+%7B%0A++++++++++++let+mut+wakers_tree+%3D+WAKERS.lock%28%29.unwrap%28%29%3B%0A++++++++++++let+wakers_vec+%3D+wakers_tree.entry%28self.wake_time%29.or_default%28%29%3B%0A++++++++++++wakers_vec.push%28context.waker%28%29.clone%28%29%29%3B%0A++++++++++++Poll%3A%3APending%0A++++++++%7D%0A++++%7D%0A%7D%0A%0Afn+sleep%28duration%3A+Duration%29+-%3E+SleepFuture+%7B%0A++++let+wake_time+%3D+Instant%3A%3Anow%28%29+%2B+duration%3B%0A++++SleepFuture+%7B+wake_time+%7D%0A%7D%0A%0A%2F%2F+%60spawn_task%60+needs+the+%60job%60+future+to+be+%60Send%60%2C+and+unfortunately%0A%2F%2F+current+compiler+limitations+mean+we+can%27t+do+that+if+%60job%60+is+an%0A%2F%2F+%60async+fn%60.+We+have+to+use+this+Box+%2B+async+block+workaround.%0Afn+job%28n%3A+u64%29+-%3E+Pin%3CBox%3Cdyn+Future%3COutput+%3D+%28%29%3E+%2B+Send%3E%3E+%7B%0A++++Box%3A%3Apin%28async+move+%7B%0A++++++++sleep%28Duration%3A%3Afrom_secs_f32%280.1%29%29.await%3B%0A++++++++println%21%28%22%7Bn%7D%22%29%3B%0A++++++++%2F%2F+Flip+a+coin%2C+and+if+it%27s+heads%2C+spawn+two+more+tasks.%0A++++++++if+rand%3A%3Arandom%28%29+%7B%0A++++++++++++spawn_task%28job%28n+%2B+1%29%29%3B%0A++++++++++++spawn_task%28job%28n+%2B+1%29%29%3B%0A++++++++%7D%0A++++%7D%29%0A%7D%0A%0Afn+spawn_task%3CF%3A+Future%3COutput+%3D+%28%29%3E+%2B+Send+%2B+%27static%3E%28future%3A+F%29+%7B%0A++++TASK_SENDER.get%28%29.unwrap%28%29.send%28Box%3A%3Apin%28future%29%29.unwrap%28%29%3B%0A%7D%0A%0Afn+main%28%29+%7B%0A++++let+%28task_sender%2C+task_receiver%29+%3D+channel%28%29%3B%0A++++TASK_SENDER.set%28task_sender%29.unwrap%28%29%3B%0A++++let+mut+context+%3D+Context%3A%3Afrom_waker%28noop_waker_ref%28%29%29%3B%0A++++println%21%28%22Start+with+one+job.+Each+job+flips+a+coin%22%29%3B%0A++++println%21%28%22and%2C+if+it%27s+heads%2C+spawns+two+more+jobs.%22%29%3B%0A++++println%21%28%22Let%27s+see+how+long+this+random+walk+can+go%21%22%29%3B%0A++++let+mut+tasks+%3D+vec%21%5Bjob%281%29%5D%3B%0A++++loop+%7B%0A++++++++%2F%2F+Poll+all+existing+tasks%2C+removing+any+that+are+finished.%0A++++++++let+is_pending+%3D+%7Ctask%3A+%26mut+Pin%3CBox%3Cdyn+Future%3COutput+%3D+%28%29%3E+%2B+Send%3E%3E%7C+%7B%0A++++++++++++task.as_mut%28%29.poll%28%26mut+context%29.is_pending%28%29%0A++++++++%7D%3B%0A++++++++tasks.retain_mut%28is_pending%29%3B%0A++++++++%2F%2F+Any+of+the+tasks+we+just+polled+might%27ve+called+spawn_task%28%29+internally.+Drain+the%0A++++++++%2F%2F+TASK_SENDER+channel+into+our+local+tasks+Vec.%0A++++++++while+let+Ok%28mut+task%29+%3D+task_receiver.try_recv%28%29+%7B%0A++++++++++++%2F%2F+Poll+each+new+tasks+once%2C+and+keep+the+ones+that+are+pending.%0A++++++++++++if+task.as_mut%28%29.poll%28%26mut+context%29.is_pending%28%29+%7B%0A++++++++++++++++tasks.push%28task%29%3B%0A++++++++++++%7D%0A++++++++%7D%0A++++++++%2F%2F+If+there+are+no+tasks+left%2C+we%27re+done%21%0A++++++++if+tasks.is_empty%28%29+%7B%0A++++++++++++break%3B%0A++++++++%7D%0A++++++++%2F%2F+Sleep+until+the+next+Waker+is+scheduled+and+then+invoke+Wakers+that+are+ready.%0A++++++++let+mut+wakers_tree+%3D+WAKERS.lock%28%29.unwrap%28%29%3B%0A++++++++let+next_wake+%3D+wakers_tree.keys%28%29.next%28%29.expect%28%22sleep+forever%3F%22%29%3B%0A++++++++std%3A%3Athread%3A%3Asleep%28next_wake.duration_since%28Instant%3A%3Anow%28%29%29%29%3B%0A++++++++while+let+Some%28entry%29+%3D+wakers_tree.first_entry%28%29+%7B%0A++++++++++++if+*entry.key%28%29+%3C%3D+Instant%3A%3Anow%28%29+%7B%0A++++++++++++++++entry.remove%28%29.into_iter%28%29.for_each%28Waker%3A%3Awake%29%3B%0A++++++++++++%7D+else+%7B%0A++++++++++++++++break%3B%0A++++++++++++%7D%0A++++++++%7D%0A++++%7D%0A%7D

## Pin

## IO
